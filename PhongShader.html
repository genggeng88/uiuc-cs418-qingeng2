#version 300 es

in vec3 aVertexPosition;
in vec3 aVertexNormal;

uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
uniform mat4 uProjectionMatrix;

out vec3 n,l,v;

void main() {
  n = normalize(uNormalMatrix*aVertexNormal);
  l = normalize(uNormalMatrix*vec3(1.0,0.25,0.0));
  vec4 p = uModelViewMatrix*vec4(aVertexPosition, 1.0);
  v = normalize(-p.xyz);

  gl_Position = uProjectionMatrix*uModelViewMatrix*vec4(aVertexPosition, 1.0);
}

#version 300 es

precision mediump float;

in vec3 n,l,v;

out vec4 outColor;

const vec4 ambientColor = 0.0* vec4(1.0, 1.0, 1.0, 1.0);
const vec4 diffuseColor = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 specularColor = vec4(1.0, 1.0, 1.0, 1.0);
const float shininess = 10.0;
const vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);

vec3 luminance = vec3(0.0, 0.0, 0.0);

void main() {
  vec3 lightDir = normalize(-l);
  vec3 viewDir = normalize(-v);
  vec3 fn = normalize(n);

  vec3 ambient = ambientColor.rgb;
  
  float diff = max(dot(-lightDir, fn), 0.0);
  vec3 diffuse = 0.5*diffuseColor.rgb*diff;
  vec3 reflectDir = reflect(-lightDir, fn);
  float spec = max(dot(reflectDir, viewDir), 0.0);
  vec3 specular = 0.5 * pow(spec, shininess) * specularColor.rgb;
  
  luminance += ambient + (diffuse + specular*diff) * lightColor.rgb;

  outColor.rgb = luminance;
  outColor.a = 1.0;
}








# Vertex Shader for Silver Surface
#version 300 es

in vec3 aVertexPosition;
in vec3 aVertexNormal;

uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
uniform mat4 uProjectionMatrix;

out vec3 n,l,v;

void main() {
  n = normalize(uNormalMatrix*aVertexNormal);
  l = normalize(uNormalMatrix*vec3(1.0,0.25,0.0));
  vec4 p = uModelViewMatrix*vec4(aVertexPosition, 1.0);
  v = normalize(-p.xyz);

  gl_Position = uProjectionMatrix*uModelViewMatrix*vec4(aVertexPosition, 1.0);
}



# Fragment Shader for Silver Surface
#version 300 es

precision mediump float;

in vec3 n,l,v;

out vec4 outColor;

const vec4 ambientColor = 0.19225*vec4(1.0, 1.0, 1.0, 1.0);
const vec4 diffuseColor = 0.50754*vec4(1.0, 1.0, 1.0, 1.0);
const vec4 specularColor = 0.508273*vec4(1.0, 1.0, 1.0, 1.0);
const float shininess = 51.2;
const vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);

vec3 luminance = vec3(0.0, 0.0, 0.0);

void main() {
  vec3 lightDir = normalize(-l);
  vec3 viewDir = normalize(-v);
  vec3 fn = normalize(n);

  vec3 ambient = ambientColor.rgb;
  
  float diff = max(dot(-lightDir, fn), 0.0);
  vec3 diffuse = diffuseColor.rgb*diff;
  vec3 reflectDir = reflect(-lightDir, fn);
  float spec = max(dot(reflectDir, viewDir), 0.0);
  vec3 specular = pow(spec, shininess) * specularColor.rgb;
  
  luminance += ambient + (diffuse + specular*diff) * lightColor.rgb;

  outColor.rgb = luminance;
  outColor.a = 1.0;
}







vec3 lightDir = normalize(-l);
  vec3 viewDir = normalize(-v);
  vec3 fn = normalize(n);

  vec3 ambient = ambientColor.rgb;
  
  float diff = max(dot(-lightDir, fn), 0.0);
  vec3 diffuse = diffuseColor.rgb*diff;
  vec3 reflectDir = reflect(-lightDir, fn);
  float spec = max(dot(reflectDir, viewDir), 0.0);
  vec3 specular = pow(spec, shininess) * specularColor.rgb;
  
  luminance += ambient + (diffuse + specular*diff) * lightColor.rgb;